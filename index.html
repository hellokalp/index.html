<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Reverse Tic-Tac-Toe — Don't Make 3!</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#0f1620;
    --muted:#9aa6b2;
    --accent:#6ff3c5;
    --accent-2:#8ab6ff;
    --danger:#ff7b8a;
    --glass: rgba(255,255,255,0.03);
    --glass-2: rgba(255,255,255,0.02);
    --glass-3: rgba(255,255,255,0.01);
    --shadow: 0 10px 30px rgba(2,6,23,0.6);
    --radius:16px;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }

  html,body{
    height:100%;
    margin:0;
    background: radial-gradient(circle at 10% 10%, rgba(138,182,255,0.04), transparent 6%),
                radial-gradient(circle at 90% 90%, rgba(111,243,197,0.03), transparent 6%),
                var(--bg);
    color:#e6eef6;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:24px;
  }

  .app {
    width:100%;
    max-width:920px;
    display:grid;
    grid-template-columns:1fr 360px;
    gap:24px;
    align-items:start;
  }

  /* responsive: single column on small screens */
  @media (max-width:880px){
    .app{ grid-template-columns:1fr; padding:0; max-width:700px; }
  }

  .panel {
    background: linear-gradient(180deg,var(--panel), #0b1118 140%);
    border-radius:var(--radius);
    padding:20px;
    box-shadow:var(--shadow);
    border:1px solid rgba(255,255,255,0.03);
    backdrop-filter: blur(6px) saturate(120%);
  }

  .board-wrap{
    display:flex;
    flex-direction:column;
    gap:16px;
  }

  .title-row{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }

  h1{
    margin:0;
    font-size:20px;
    letter-spacing:0.2px;
  }

  .subtitle{ color:var(--muted); font-size:13px; margin-top:6px; }

  /* Board container maintains square shape */
  .board {
    width:100%;
    aspect-ratio:1 / 1;
    background: linear-gradient(180deg,var(--glass), var(--glass-2));
    border-radius:12px;
    padding:14px;
    display:grid;
    grid-template-columns: repeat(3,1fr);
    grid-template-rows: repeat(3,1fr);
    gap:12px;
    align-items:stretch;
    justify-items:stretch;
    touch-action: manipulation;
  }

  .cell {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:10px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:clamp(28px, 7vw, 56px);
    font-weight:700;
    color:var(--accent);
    position:relative;
    transition: transform 220ms cubic-bezier(.2,.9,.25,1), box-shadow 220ms;
    box-shadow: 0 6px 18px rgba(2,6,23,0.45);
    user-select:none;
  }

  .cell:hover{ transform: translateY(-6px) scale(1.02); }
  .cell.locked{ opacity:0.68; transform:none; pointer-events:none; }
  .cell.x{ color:var(--accent-2); }
  .cell.o{ color:var(--accent); }

  /* subtle animated stroke when placed */
  .symbol {
    transform: scale(0.6) rotate(-8deg);
    opacity:0;
    transition: transform 360ms cubic-bezier(.2,.9,.25,1), opacity 260ms;
    text-shadow: 0 6px 18px rgba(0,0,0,0.5);
  }
  .cell.filled .symbol{ transform:scale(1) rotate(0); opacity:1; }

  .controls {
    display:flex;
    gap:8px;
    margin-top:8px;
    flex-wrap:wrap;
  }

  .btn {
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    padding:10px 12px;
    border-radius:12px;
    color:var(--muted);
    cursor:pointer;
    font-weight:600;
    transition: all 180ms;
    display:inline-flex;
    gap:8px;
    align-items:center;
  }
  .btn:hover{ transform:translateY(-4px); color: #fff; border-color: rgba(255,255,255,0.08); }
  .btn.primary{
    background: linear-gradient(90deg,var(--accent), var(--accent-2));
    color:#042025;
    border:0;
    box-shadow: 0 8px 30px rgba(71,200,180,0.08), inset 0 -2px 8px rgba(0,0,0,0.12);
  }

  .side {
    display:flex;
    flex-direction:column;
    gap:16px;
  }

  .meta{
    display:flex;
    flex-direction:column;
    gap:8px;
  }

  .status {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:12px;
    border-radius:12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  .status p{ margin:0; font-size:14px; color:var(--muted) }
  .turn {
    display:flex;
    align-items:center;
    gap:10px;
    font-weight:700;
  }

  .small{
    font-size:13px;
    color:var(--muted);
  }

  footer.small { color:var(--muted); font-size:12px; text-align:center; margin-top:6px; }

  /* highlight losing line */
  .line-highlight{
    position:absolute;
    left:0; top:0; right:0; bottom:0;
    border-radius:inherit;
    background: linear-gradient(90deg, rgba(255,0,0,0.06), rgba(255,0,0,0.03));
    pointer-events:none;
    opacity:0;
    transition: opacity 300ms;
  }
  .cell.loser .line-highlight{ opacity:1; }

  /* simple CPU toggle */
  .row { display:flex; gap:8px; align-items:center; }

  /* small helpful hint section */
  .hint{
    color:var(--muted);
    font-size:13px;
    line-height:1.25;
  }
</style>
</head>
<body>
  <main class="app" role="main">
    <section class="panel board-wrap" aria-label="Game board">
      <div class="title-row">
        <div>
          <h1>Reverse Tic-Tac-Toe</h1>
          <div class="subtitle">Don't be the player who makes 3 in a row — you lose instantly.</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <button class="btn" id="undoBtn" title="Undo last move">↶ Undo</button>
          <button class="btn primary" id="restartBtn" title="Restart">Restart</button>
        </div>
      </div>

      <div id="board" class="board" role="grid" aria-label="3 by 3 game board">
        <!-- cells injected by JS -->
      </div>

      <div class="controls" aria-hidden="false">
        <div class="row" style="align-items:center; gap:12px;">
          <label class="small" for="mode">Mode</label>
          <select id="mode" class="btn" style="padding:8px 10px;">
            <option value="pvp">2 Players (Local)</option>
            <option value="cpu">Play vs CPU (Easy)</option>
          </select>
          <label class="small" style="margin-left:8px;">
            <input type="checkbox" id="showHints" /> Show hints
          </label>
        </div>
      </div>

      <div style="margin-top:8px;" class="hint">
        Tip: Try to force your opponent into a spot that would make 3-in-a-row. The moment a player *creates* 3 identical symbols consecutively (row/column/diagonal) they **lose**.
      </div>
    </section>

    <aside class="panel side" aria-label="Game info">
      <div class="meta">
        <div class="status">
          <div>
            <div class="small">Current turn</div>
            <div class="turn" id="turnDisplay"><span id="turnSymbol">X</span> <span class="small" id="turnText">Player 1</span></div>
          </div>
          <div style="text-align:right">
            <div class="small">Moves</div>
            <div id="moveCount" style="font-weight:700">0</div>
          </div>
        </div>

        <div style="display:flex;gap:8px;">
          <button class="btn" id="hintBtn">Hint</button>
          <button class="btn" id="surrenderBtn">Surrender</button>
        </div>
      </div>

      <div style="padding:12px;border-radius:12px;background:linear-gradient(180deg,var(--glass-2),var(--glass-3));">
        <div class="small" style="margin-bottom:8px">Game log</div>
        <div id="log" style="max-height:220px;overflow:auto;color:var(--muted);font-size:13px;"></div>
      </div>

      <footer style="margin-top:auto;">
        <div class="small" style="text-align:center;">Made for quick fun — drop into Git & deploy to Vercel</div>
      </footer>
    </aside>
  </main>

<script>
/*
Reverse Tic-Tac-Toe (misère). Rules implemented:
- Players alternate placing X and O.
- If a player places a symbol that forms a 3-in-a-row (horizontal/vertical/diagonal) of their symbol, they immediately LOSE.
- If board gets full with no 3-in-a-row, it's a DRAW.
- Simple CPU: picks a move that doesn't lose immediately; otherwise picks random.
*/

const boardEl = document.getElementById('board');
const turnSymbolEl = document.getElementById('turnSymbol');
const turnTextEl = document.getElementById('turnText');
const moveCountEl = document.getElementById('moveCount');
const logEl = document.getElementById('log');
const undoBtn = document.getElementById('undoBtn');
const restartBtn = document.getElementById('restartBtn');
const hintBtn = document.getElementById('hintBtn');
const surrenderBtn = document.getElementById('surrenderBtn');
const modeSelect = document.getElementById('mode');
const showHintsCheckbox = document.getElementById('showHints');

let board = Array(9).fill(null);
let turn = 'X'; // X starts
let moves = [];
let gameOver = false;

function createBoard(){
  boardEl.innerHTML = '';
  for(let i=0;i<9;i++){
    const c = document.createElement('button');
    c.className = 'cell';
    c.setAttribute('role','gridcell');
    c.setAttribute('data-index', i);
    c.tabIndex = 0;
    c.innerHTML = '<div class="symbol" aria-hidden="true"></div><div class="line-highlight"></div>';
    c.addEventListener('click', onCellClick);
    c.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' ') { e.preventDefault(); c.click(); } });
    boardEl.appendChild(c);
  }
}

function render(){
  moveCountEl.textContent = moves.length;
  turnSymbolEl.textContent = turn;
  turnSymbolEl.style.color = turn === 'X' ? '' : '';
  turnTextEl.textContent = modeSelect.value === 'cpu' && turn==='O' ? 'CPU' : (turn === 'X' ? 'Player 1' : 'Player 2');
  for(let i=0;i<9;i++){
    const el = boardEl.children[i];
    el.classList.remove('filled','x','o','locked','loser');
    const s = el.querySelector('.symbol');
    if(board[i]){
      el.classList.add('filled', board[i].toLowerCase());
      s.textContent = board[i];
    } else {
      s.textContent = '';
    }
  }
}

function indexToRC(i){
  return [Math.floor(i/3), i%3];
}

function winningTriplesForSymbol(sym){
  const b = board;
  const lines = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ];
  return lines.filter(line => line.every(idx => b[idx] === sym));
}

function checkLossAfterMove(idx, sym){
  // temporarily place and test
  const prev = board[idx];
  board[idx] = sym;
  const triples = winningTriplesForSymbol(sym);
  board[idx] = prev;
  return triples.length > 0;
}

function onCellClick(e){
  if(gameOver) return;
  const idx = Number(this.dataset.index);
  if(board[idx]) return;
  // make the move
  makeMove(idx, turn);
}

function makeMove(idx, player){
  if(gameOver) return;
  // place
  board[idx] = player;
  moves.push({idx, player});
  log(`${player} → ${idxToRC(idx).join(',')}`);
  // animation: add filled class
  const el = boardEl.children[idx];
  el.classList.add('filled');
  setTimeout(render, 30);

  // check if move causes immediate loss for the mover
  if(winningTriplesForSymbol(player).length > 0){
    // mover loses
    el.classList.add('loser');
    endGame(`${player} made 3-in-a-row and loses!`);
    return;
  }

  // check draw
  if(moves.length === 9){
    endGame("Draw — board full, no 3-in-a-row.");
    return;
  }

  // switch turn
  turn = (turn === 'X') ? 'O' : 'X';
  render();

  // CPU move if applicable
  if(!gameOver && modeSelect.value === 'cpu' && turn === 'O'){
    setTimeout(cpuMove, 280 + Math.random()*200);
  }
}

function cpuMove(){
  // Very simple CPU:
  // 1) find safe moves (won't immediately cause CPU to lose)
  // 2) if no safe move, choose any move (will lose)
  // 3) prefer moves that don't give opponent immediate trap (basic check)
  const empty = board.map((v,i)=>v?null:i).filter(x=>x!==null);
  // prefer center then corners then sides
  const priorities = [4,0,2,6,8,1,3,5,7];
  let safe = [];
  for(const idx of empty){
    if(!checkLossAfterMove(idx, 'O')) safe.push(idx);
  }
  let candidate = null;
  if(safe.length){
    // avoid giving opponent an immediate safe move that makes them avoid losing.
    candidate = priorities.find(p => safe.includes(p));
    if(candidate === undefined) candidate = safe[Math.floor(Math.random()*safe.length)];
  } else {
    // no safe move: choose least-bad
    candidate = priorities.find(p => empty.includes(p));
  }
  if(candidate != null) makeMove(candidate, 'O');
}

function undo(){
  if(moves.length === 0 || gameOver) return;
  const last = moves.pop();
  board[last.idx] = null;
  // if CPU mode and last was CPU's move, remove another to return to player's turn
  if(modeSelect.value === 'cpu' && last.player === 'O' && moves.length>0){
    const prev = moves.pop();
    board[prev.idx] = null;
    turn = prev.player;
  } else {
    turn = last.player === 'X' ? 'O' : 'X';
  }
  gameOver = false;
  clearHighlights();
  render();
  log('Undo');
}

function clearHighlights(){
  for(let i=0;i<9;i++) boardEl.children[i].classList.remove('loser');
}

function endGame(message){
  gameOver = true;
  log('Game over — ' + message);
  // lock empty cells and show small shake on loser cell(s)
  for(let i=0;i<9;i++){
    const el = boardEl.children[i];
    if(!board[i]) el.classList.add('locked');
  }
  // highlight losing triples if present
  const loserSymbol = turn; // it was the mover who caused the loss
  const triples = winningTriplesForSymbol(loserSymbol);
  triples.forEach(line=>{
    line.forEach(idx => boardEl.children[idx].classList.add('loser'));
  });
  // show final overlay via log
  setTimeout(()=> alert(message), 150);
  render();
}

function restart(){
  board = Array(9).fill(null);
  moves = [];
  turn = 'X';
  gameOver = false;
  log('Restarted');
  clearHighlights();
  render();
}

function hint(){
  if(gameOver) return;
  // find safe moves for current player
  const empty = board.map((v,i)=>v?null:i).filter(x=>x!==null);
  const safes = empty.filter(i => !checkLossAfterMove(i, turn));
  if(safes.length === 0){
    log('No safe move — any move will lose or lead to loss.');
    alert('No safe move: every possible move would make you lose or create a 3-in-a-row later.');
    return;
  }
  // pick best safe (prefer center)
  const priorities = [4,0,2,6,8,1,3,5,7];
  const pick = priorities.find(p => safes.includes(p));
  // visually hint the cell:
  const el = boardEl.children[pick];
  el.animate([
    { boxShadow: '0 10px 30px rgba(111,243,197,0.05)', transform:'translateY(-6px) scale(1.03)'},
    { boxShadow: '0 6px 18px rgba(2,6,23,0.45)', transform:'translateY(0) scale(1)'}
  ], { duration:420, easing:'ease' });
  log(`Hint suggests ${indexToRC(pick).join(',')}`);
}

function log(text){
  const el = document.createElement('div');
  const t = new Date();
  const time = t.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});
  el.textContent = `[${time}] ${text}`;
  logEl.prepend(el);
  // keep first 80 entries
  while(logEl.children.length > 80) logEl.removeChild(logEl.lastChild);
}

// events
undoBtn.addEventListener('click', undo);
restartBtn.addEventListener('click', ()=>{ if(confirm('Restart the game?')) restart(); });
hintBtn.addEventListener('click', hint);
surrenderBtn.addEventListener('click', ()=>{ if(confirm('Surrender? This will end the game.')) { endGame(`${turn} surrendered. ${turn==='X'?'O':'X'} wins!`); } });
modeSelect.addEventListener('change', ()=>{ restart(); });

showHintsCheckbox.addEventListener('change', ()=> {
  // small visual addition: show available safe cells
  const show = showHintsCheckbox.checked;
  for(let i=0;i<9;i++) boardEl.children[i].style.outline = show && !board[i] && !checkLossAfterMove(i, turn) ? '2px solid rgba(111,243,197,0.08)' : '';
});

// init
createBoard();
render();

// Responsive tip: allow board to reflow nicely; ensure tap areas are roomy on mobile.
</script>
</body>
</html>
